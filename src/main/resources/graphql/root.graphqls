scalar LocalDate

extend type Query {
    #cart(secureKey: String): Cart
    tenantCheckout(secureKey: String): Cart
    carriers(secureKey: String): [Carrier]
    #paymentMethods(currency: String): [PaymentMethod]
    addressDescription(isoCode: String, lang: String): AddressFormat
    orderConfirmation(paymentKey: String): OrderConfirmation

#    stockReportBetweenDates(from: LocalDate, to: LocalDate): [StockReport]

}
extend type Mutation {

    #setInfo(email: String, address: AddressInput, secureKey: String, carrier: String): Cart

    setTenantInfo(email: String, address: AddressInput, secureKey: String, carrier: String): Cart
    setTenantCarrier(value: String, secureKey: String): Cart
    processTenantPayment(token: String, ref: String, secureKey: String): PaymentResponsePayload

    processPayment(token: String, ref: String, secureKey: String): PaymentResponsePayload
    #setCarrier(value: String, secureKey: String): Cart
    chargePayment(token: String, paymentRef: String, secureKey: String): PaymentResponsePayload
    #createOrder(token: String, paymentKey: String): OrderConfirmation

    useReward(secureKey: String, reward: String): Message
    removeReward(secureKey: String, reward: String): Message
}


enum AddressField {
    firstName, lastName, line1, line2, postalCode, state, city, mobile, alias, country, save
}

enum OptionType {
    REQUIRED, OPTIONAL, NONE
}

enum FieldType {
    TEXT, REMOTE_SELECT, REMOTE_AUTOCOMPLETE, SELECT, CHECKBOX, AUTOCOMPLETE, MOBILE
}

enum DiscountReductionType {
    AMOUNT
    PERCENT
}

enum DiscountSource {
    REWARD
    COUPON
}

type AdjustmentProfile {
    discount: String
    discountReductionType: DiscountReductionType
    discountSource: DiscountSource
    sourceRef: String
}

type PriceMap {
    prices: String
    base: String
}

type Message {
    value: String
    status: String
}

type AddressFormat {
    inputFormat: String
    displayFormat: String
    descriptions: [FieldDescription]
    gmap: OptionType
}

type FieldDescription {
    field: AddressField
    label: String
    required: Boolean
    minLength: Int
    maxLength: Int
    regex: String
    fieldType: FieldType
    options: [Option]
}

type Option {
    label: String
    value: String
}
enum PaymentStatus {
    SUCCESS
    DECLINED
    REDIRECT
    IGNORED
}
type PaymentResponsePayload {
    message: String
    payload: String
    status: PaymentStatus
    ref: String
}
type Carrier {
    id: Int
    name: String!
    value: String!
    cost: BigDecimal!
    logo: String
}
type Address {
    id: Long
    alias: String
    firstName: String
    lastName: String
    line1: String
    line2: String
    city: String
    state: String
    country: String
    postalCode: String
    mobile: String
    save: Boolean
    lng: String
    lat: String
    plusCode: String
}
type PaymentMethod {
    ref: String
    name: String
    image: String
    label: String
}
type CartItem {
    productId: Long
    sku: String
    image: String
    name: String
    quantity: Float
    price: Float
    subTotal: Float
}
type Cart {
    id: ID!
    ref: String
    name: String
    phone: String
    email: String
    secureKey: String
    deliveryAddress: Address
    deliveryAddressId: Long
    invoiceAddress: Address
    addresses: [Address]
    paymentTypes: [PaymentMethod]
    carrier: String
    currency: String
    items: [CartItem]
    tenantId: String
    allowPickup: Boolean
    guest: Boolean
    carrierRate:String
    carrierService: String
    adjustments: [AdjustmentProfile]
    additionalInfo: AdditionalInfoDto
}
input AddressInput {
     id: Long
     firstName: String
     lastName: String
     line1: String
     line2: String
     city: String
     state: String
     country: String
     postalCode: String
     mobile: String
     save: Boolean
     alias: String
     lng: String
     lat: String
     plusCode: String
}

#type OrderConfirmation {
#    reference: String
#    cart: Cart
#    code: String
#    success: Boolean
#    message: String
#}

type OrderConfirmation {
    id: Long
    reference: String
    invoiceDate: LocalDate
    deliveryDate: LocalDate
    currency: String
    cart: Cart
    confirmationKey: String
}

type Reward {
    rewardType: String
    points: Int
    rewardInfo: [RewardInfo]
}

type RewardInfo {
    language: String
    name: String
    description: String
}


type AdditionalInfoDto {
    date: String
    zipcode: String
    sender_zipcode: String
    email: String
    name: String
    company: String
    city: String
    state: String
    address: String
    address_opt: String
    sender_name: String
    sender_company: String
    sender_address: String
    sender_address_opt: String
    sender_city: String
    items: [Item]
    requestedPackageLineItems: [PackageLineItem]
    sender_phone: String
    receiver_phone: String
    receiver_countryCode: String
}

type Item {
    name: String
    description: String
    harmonizedCode: String
    countryOfManufacture: String
    quantity: Int
    quantityUnits: String
    weight: Weight
    customsValue: CustomsValue
    partNumber: String
    numberOfPieces: Int
    unitPrice: String# Assuming unitPrice is an object, can be customized as needed
}

type Weight {
    value: Float
    units: String
}

type CustomsValue {
    amount: Float
    currency: String
}

type PackageLineItem {
    weight: Weight
    dimensions: Dimensions
}

type Dimensions {
    length: Float
    width: Float
    height: Float
    units: String
}

input WeightInput {
    value: Float
    units: String
}

input CustomsValueInput {
    amount: Float
    currency: String
}

input ItemInput {
    name: String
    description: String
    harmonizedCode: String
    countryOfManufacture: String
    quantity: Int
    quantityUnits: String
    weight: WeightInput
    customsValue: CustomsValueInput
    partNumber: String
    numberOfPieces: Int
    unitPrice: String
}

input DimensionsInput {
    length: Float
    width: Float
    height: Float
    units: String
}

input PackageLineItemInput {
    weight: WeightInput
    dimensions: DimensionsInput
}


input AdditionalInfoInputDto {
    date: String
    zipcode: String
    sender_zipcode: String
    email: String
    name: String
    company: String
    city: String
    state: String
    address: String
    address_opt: String
    sender_name: String
    sender_company: String
    sender_address: String
    sender_address_opt: String
    sender_city: String
    items: [ItemInput]
    requestedPackageLineItems: [PackageLineItemInput]
    sender_phone: String
    receiver_phone: String
    receiver_countryCode: String
}
